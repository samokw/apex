import { NextRequest, NextResponse } from "next/server";
import { getApexSession } from "@/lib/session";
import { prisma } from "@/lib/db";
import { createBranch, applyFixToFile, createPullRequest } from "@/lib/github";
import { generateReportSummary } from "@/lib/wcag";
import { finishEscrow } from "@/lib/xrpl-escrow";

export async function POST(req: NextRequest) {
  const session = await getApexSession();
  if (!session) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  const { scanId, paymentId } = await req.json();
  if (!scanId) {
    return NextResponse.json({ error: "Missing scanId" }, { status: 400 });
  }

  // Verify escrow payment exists
  const payment = paymentId
    ? await prisma.payment.findUnique({ where: { id: paymentId } })
    : await prisma.payment.findFirst({
        where: {
          userId: session.dbUserId,
          scanId,
          paymentType: "pr-credit",
          status: { in: ["escrowed", "confirmed"] },
        },
      });

  if (!payment || payment.userId !== session.dbUserId) {
    return NextResponse.json(
      { error: "Payment required. Create an escrow for 2 XRP first.", code: "PAYMENT_REQUIRED" },
      { status: 402 }
    );
  }

  const scan = await prisma.scan.findUnique({
    where: { id: scanId, userId: session.dbUserId },
    include: {
      violations: true,
      fixes: { where: { status: "accepted" } },
    },
  });

  if (!scan) {
    return NextResponse.json({ error: "Scan not found" }, { status: 404 });
  }

  if (scan.fixes.length === 0) {
    return NextResponse.json({ error: "No accepted fixes" }, { status: 400 });
  }

  try {
    const branchName = `apex/a11y-fixes-${Date.now()}`;
    await createBranch(
      session.accessToken,
      scan.repoOwner,
      scan.repoName,
      branchName,
      scan.branch
    );

    for (const fix of scan.fixes) {
      await applyFixToFile(
        session.accessToken,
        scan.repoOwner,
        scan.repoName,
        branchName,
        fix.filePath,
        fix.originalCode,
        fix.fixedCode,
        `fix(a11y): ${fix.explanation?.substring(0, 72) || "Fix accessibility violation"}`
      );
    }

    const report = generateReportSummary(
      scan.violations.map((v) => ({
        impact: v.impact,
        ruleId: v.ruleId,
        description: v.description,
        wcagCriteria: v.wcagCriteria,
        aodaRelevant: v.aodaRelevant,
      }))
    );

    const prBody = `## Apex Accessibility Remediation

### Summary
- **Violations Found**: ${report.totalViolations}
- **Fixes Applied**: ${scan.fixes.length}
- **Score Before**: ${scan.score ?? "N/A"}/100
- **Score After**: ${scan.scoreAfter ?? "N/A"}/100

### Severity Breakdown
| Level | Count |
|-------|-------|
| Critical | ${report.bySeverity.critical} |
| Serious | ${report.bySeverity.serious} |
| Moderate | ${report.bySeverity.moderate} |
| Minor | ${report.bySeverity.minor} |

### AODA/IASR Relevance
${report.aodaRelevantCount} violation(s) are relevant to Ontario IASR Information and Communications Standard (WCAG 2.0 AA).

### Fixes Applied
${scan.fixes.map((f, i) => `${i + 1}. \`${f.filePath}\`: ${f.explanation}`).join("\n")}

---

> ${report.disclaimer}

*Generated by [Apex](https://github.com/apex-a11y) — AI Accessibility Remediation*`;

    const { prUrl, prNumber } = await createPullRequest(
      session.accessToken,
      {
        owner: scan.repoOwner,
        repo: scan.repoName,
        title: `[Apex] Accessibility fixes — ${scan.fixes.length} issue(s) remediated`,
        body: prBody,
        head: branchName,
        base: scan.branch,
      }
    );

    await prisma.pullRequest.create({
      data: {
        scanId,
        prUrl,
        prNumber,
        branchName,
        status: "open",
      },
    });

    // Release escrowed XRP to Apex on success
    if (payment.status === "escrowed" && payment.escrowOwner && payment.escrowOfferSequence != null) {
      try {
        const result = await finishEscrow(payment.escrowOwner, payment.escrowOfferSequence);
        await prisma.payment.update({
          where: { id: payment.id },
          data: { status: "confirmed", txHash: result.txHash },
        });
      } catch (escrowErr) {
        console.error("EscrowFinish failed (PR succeeded):", escrowErr);
      }
    }

    return NextResponse.json({ prUrl, prNumber, branchName });
  } catch (err) {
    const msg = err instanceof Error ? err.message : "PR creation failed";
    return NextResponse.json({ error: msg }, { status: 500 });
  }
}
